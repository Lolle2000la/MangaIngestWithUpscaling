@using System.Collections.ObjectModel
@using System.Text.RegularExpressions
@using DynamicData
@using MangaIngestWithUpscaling.Data.LibraryManagement
@using MangaIngestWithUpscaling.Helpers
@using MangaIngestWithUpscaling.Services.Analysis
@using MangaIngestWithUpscaling.Services.BackgroundTaskQueue
@using MangaIngestWithUpscaling.Services.BackgroundTaskQueue.Tasks
@using MangaIngestWithUpscaling.Services.ChapterMerging
@using MangaIngestWithUpscaling.Services.Integrations
@using MangaIngestWithUpscaling.Services.LibraryIntegrity
@using MangaIngestWithUpscaling.Services.MetadataHandling
@using MangaIngestWithUpscaling.Shared.Services.FileSystem
@using MangaIngestWithUpscaling.Shared.Services.MetadataHandling
@using MangaIngestWithUpscaling.Shared.Services.Analysis
@using MangaIngestWithUpscaling.Data.Analysis
@using Microsoft.Extensions.Localization
@using MangaIngestWithUpscaling.Shared.Helpers
@using Humanizer
@using System.Globalization
@inject ISplitApplicationService SplitApplicationService
@inject ApplicationDbContext DbContext
@inject IMetadataHandlingService MetadataHandler
@inject IMangaMetadataChanger MangaMetadataChanger
@inject ITaskQueue TaskQueue
@inject ILogger<ChapterList> Logger
@inject IDialogService DialogService
@inject ISnackbar Snackbar
@inject ILibraryIntegrityChecker LibraryIntegrityChecker
@inject IFileSystem FileSystem
@inject IChapterChangedNotifier ChapterChangedNotifier
@inject IChapterMergeRevertService ChapterMergeRevertService
@inject IChapterMergeCoordinator ChapterMergeCoordinator
@inject IWebHostEnvironment WebHostEnvironment
@inject ISplitProcessingService SplitProcessingService
@inject ISplitProcessingCoordinator SplitProcessingCoordinator
@inject ISplitProcessingStateManager SplitStateManager
@inject IStringLocalizer<ChapterList> Loc
@inject IStringLocalizer<SharedResource> SharedLoc

<MudTable T="ChapterItem" @bind-SelectedItems="selectedChapters" Items="@chapterItems" Dense="true"
    MultiSelection="true" CanCancelEdit="true" RowEditCommit="r => _ = OnChapterMetadataCommit(r as ChapterItem)"
    RowEditCancel="r => OnChapterMetadataDiscard(r as ChapterItem)">
    <ToolBarContent>
        <MudStack Row>
            <MudButton StartIcon="@Icons.Material.Filled.Delete" Color="Color.Error" Variant="Variant.Text"
                Disabled="selectedChapters.Count == 0" OnClick="@(async () => await DeleteSelected())">
                @Loc["Button_DeleteSelected"]
            </MudButton>
            <MudButton StartIcon="@Icons.Material.Filled.ArrowUpward" Color="Color.Primary" Variant="Variant.Text"
                Disabled="selectedChapters.Count == 0 || selectedChapters.All(c => c.Chapter.IsUpscaled)"
                OnClick="@UpscaleSelectedChapters">
                @Loc["Button_UpscaleSelected"]
            </MudButton>
            <MudButton StartIcon="@Icons.Material.Filled.ArrowDownward" Color="Color.Secondary" Variant="Variant.Text"
                Disabled="selectedChapters.Count == 0 || !selectedChapters.Any(c => c.Chapter.IsUpscaled)"
                OnClick="@DeleteSelectedUpscaled">
                @Loc["Button_DeleteUpscaledSelected"]
            </MudButton>
            <MudButton StartIcon="@Icons.Material.Filled.Undo" Color="Color.Warning" Variant="Variant.Text"
                Disabled="selectedChapters.Count == 0 || !selectedChapters.Any(c => c.IsMerged)"
                OnClick="@RevertSelectedMergedChapters">
                @Loc["Button_RevertSelectedMerged"]
            </MudButton>
            <MudButton StartIcon="@Icons.Material.Filled.MergeType" Color="Color.Info" Variant="Variant.Text"
                Disabled="selectedChapters.Count == 0 || !CanAnySelectedBeMerged" OnClick="@MergeSelectedChapters">
                @Loc["Button_MergeSelected"]
            </MudButton>
        </MudStack>
        @if (WebHostEnvironment.IsDevelopment())
        {
            <MudText Typo="Typo.caption" Color="Color.Secondary" Style="margin-top: 8px;">
                DEBUG: Merge Cache Status -
                @if (_cachedMergePossibilities == null)
                {
                    <span style="color: red;">Not Loaded</span>
                }
                else
                {
                    <span style="color: green;">
                        Loaded (@((DateTime.UtcNow - _lastMergePossibilitiesUpdate).TotalSeconds.ToString("F1"))s ago) -
                        New: @_cachedMergePossibilities.NewMergeGroups.Count,
                        Additions: @_cachedMergePossibilities.AdditionsToExistingMerged.Count,
                        HasAny: @_cachedMergePossibilities.HasAnyMergePossibilities
                    </span>
                }
            </MudText>
        }
    </ToolBarContent>
    <HeaderContent>
        <MudTh>@Loc["Header_ChapterTitle"]</MudTh>
        <MudTh>@Loc["Header_ChapterPath"]</MudTh>
        <MudTh>@Loc["Header_Upscaled"]</MudTh>
        <MudTh>@Loc["Header_Splits"]</MudTh>
        <MudTh>@Loc["Header_UpscalerProfile"]</MudTh>
        <MudTh>@Loc["Header_Actions"]</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="@Loc["Header_ChapterTitle"]">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                <MudText>@(context.ExtractedMetadata?.ChapterTitle ?? Loc["Text_NotAvailable"])</MudText>
                @if (context.IsMerged)
                {
                    <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Filled">
                        <MudIcon Icon="@Icons.Material.Filled.CallMerge" Size="Size.Small" />
                        @Loc["Chip_Merged"]
                    </MudChip>
                }
            </MudStack>
        </MudTd>
        <MudTd DataLabel="@Loc["Header_ChapterPath"]">@context.Chapter.RelativePath</MudTd>
        <MudTd DataLabel="@Loc["Header_Upscaled"]">
            @(context.Chapter.IsUpscaled? Loc["Status_Yes"] : Loc["Status_No"])
            @if (!context.Chapter.IsUpscaled)
            {
                <MudIconButton Icon="@Icons.Material.Filled.ArrowUpward" Color="Color.Primary" Variant="Variant.Text"
                    OnClick="@(() => UpscaleChapter(context.Chapter))" title="@Loc["Tooltip_Upscale"]" />
            }
            else
            {
                <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward" Color="Color.Secondary" Variant="Variant.Text"
                    OnClick="@(() => DeleteUpscaledConfirm(context.Chapter))" title="@Loc["Tooltip_DeleteUpscaled"]" />
            }
        </MudTd>
        <MudTd DataLabel="@Loc["Header_Splits"]">
            @switch (context.SplitState?.Status)
            {
                case SplitProcessingStatus.Pending:
                    <MudChip T="string" Size="Size.Small" Color="Color.Default" Variant="Variant.Outlined">@Loc["Chip_Pending"]
                    </MudChip>
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Color="Color.Info" />
                    break;
                case SplitProcessingStatus.Detected:
                    if (context.SplitFindingsCount > 0)
                    {
                        <MudMenu ActivationEvent="@MouseEvent.MouseOver" AnchorOrigin="Origin.BottomCenter"
                            TransformOrigin="Origin.TopCenter">
                            <ActivatorContent>
                                <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Filled">
                                    @Loc["Chip_Detected"]</MudChip>
                            </ActivatorContent>
                            <ChildContent>
                                <MudMenuItem OnClick="@(() => ViewSplits(context.Chapter))">@Loc["Menu_ViewEdit"]</MudMenuItem>
                                <MudMenuItem OnClick="@(() => ApplySplits(context.Chapter))">@Loc["Menu_ApplySplits"]</MudMenuItem>
                            </ChildContent>
                        </MudMenu>
                    }
                    else
                    {
                        <MudChip T="string" Size="Size.Small" Color="Color.Surface" Variant="Variant.Outlined">@Loc["Chip_NoSplits"]
                        </MudChip>
                        <MudTooltip Text="@Loc["Tooltip_RedetectSplits"]">
                            <MudIconButton Icon="@Icons.Material.Filled.Refresh" Size="Size.Small"
                                OnClick="@(() => DetectSplits(context.Chapter))" />
                        </MudTooltip>
                    }
                    break;
                case SplitProcessingStatus.NoSplitsFound:
                    <MudChip T="string" Size="Size.Small" Color="Color.Surface" Variant="Variant.Outlined">@Loc["Chip_NoSplits"]
                    </MudChip>
                    <MudTooltip Text="@Loc["Tooltip_RedetectSplits"]">
                        <MudIconButton Icon="@Icons.Material.Filled.Refresh" Size="Size.Small"
                            OnClick="@(() => DetectSplits(context.Chapter))" />
                    </MudTooltip>
                    break;
                case SplitProcessingStatus.Applied:
                    <MudChip T="string" Size="Size.Small" Color="Color.Success" Variant="Variant.Filled">@Loc["Chip_Applied"]
                    </MudChip>
                    break;
                case SplitProcessingStatus.Failed:
                    <MudChip T="string" Size="Size.Small" Color="Color.Error" Variant="Variant.Filled">@Loc["Chip_Failed"]
                    </MudChip>
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh" Size="Size.Small"
                        OnClick="@(() => DetectSplits(context.Chapter))" Title="@Loc["Tooltip_RetryDetection"]" />
                    break;
                default:
                    <MudIconButton Icon="@Icons.Material.Filled.Search" Size="Size.Small"
                        OnClick="@(() => DetectSplits(context.Chapter))" Title="@Loc["Tooltip_DetectSplits"]" />
                    break;
            }
        </MudTd>
        <MudTd DataLabel="@Loc["Header_UpscalerProfile"]">
            @(context.Chapter.UpscalerProfile?.Deleted == true ? $"{context.Chapter.UpscalerProfile.Name}            {Loc["Suffix_Old"]}" :
                        context.Chapter.UpscalerProfile?.Name)
        </MudTd>
        <MudTd DataLabel="@Loc["Header_Actions"]">
            <MudStack Row="true" Spacing="1">
                @if (context.IsMerged)
                {
                    <MudIconButton Icon="@Icons.Material.Filled.Undo" Color="Color.Warning" Variant="Variant.Text"
                        OnClick="@(() => RevertMergedChapterConfirm(context.Chapter))"
                        title="@Loc["Tooltip_RevertMerged"]" />
                }
                @if (CanManualMergeChapterSync(context.Chapter))
                {
                    <MudIconButton Icon="@Icons.Material.Filled.MergeType" Color="Color.Info" Variant="Variant.Text"
                        OnClick="@(() => MergeChapterConfirm(context.Chapter))" title="@Loc["Tooltip_MergeChapter"]" />
                }
                <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" Variant="Variant.Text"
                    OnClick="@(() => DeleteChapterConfirm(context.Chapter))" title="@Loc["Tooltip_DeleteChapter"]" />
            </MudStack>
        </MudTd>
    </RowTemplate>
    <RowEditingTemplate>
        <MudTd DataLabel="@Loc["Header_ChapterTitle"]">
            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                <MudInput @bind-Value="context.NewTitle" />
                @if (context.IsMerged)
                {
                    <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Filled">
                        <MudIcon Icon="@Icons.Material.Filled.CallMerge" Size="Size.Small" />
                        @Loc["Chip_Merged"]
                    </MudChip>
                }
            </MudStack>
        </MudTd>
        <MudTd DataLabel="@Loc["Header_ChapterPath"]">
            <MudInput @bind-Value="context.NewFileName" Label="@Loc["Label_Filename"]"
                HelperText="@Loc["Label_Filename"]" />
            .cbz
        </MudTd>
        <MudTd DataLabel="@Loc["Header_Upscaled"]">
            @context.Chapter.IsUpscaled
            @if (!context.Chapter.IsUpscaled)
            {
                <MudIconButton Icon="@Icons.Material.Filled.ArrowUpward" Color="Color.Primary" Variant="Variant.Text"
                    OnClick="@(() => UpscaleChapter(context.Chapter))" title="@Loc["Tooltip_Upscale"]" />
            }
            else
            {
                <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward" Color="Color.Secondary" Variant="Variant.Text"
                    OnClick="@(() => DeleteUpscaledConfirm(context.Chapter))" title="@Loc["Tooltip_DeleteUpscaled"]" />
            }
        </MudTd>
        <MudTd DataLabel="@Loc["Header_UpscalerProfile"]">
            @(context.Chapter.UpscalerProfile?.Deleted == true ? $"{context.Chapter.UpscalerProfile.Name}            {Loc["Suffix_Old"]}" :
                        context.Chapter.UpscalerProfile?.Name)
        </MudTd>
    </RowEditingTemplate>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>

@code {
    [Parameter] public required Manga Manga { get; set; }

    private ReadOnlyObservableCollection<ChapterItem> chapterItems = new([]);
    private SourceList<ChapterItem> chapters = new();

    private HashSet<ChapterItem> selectedChapters = new();


    private async Task DeleteSelected()
    {
        var result = await DialogService.ShowMessageBox(Loc["Dialog_DeleteSelected_Title"],
        Loc["Dialog_DeleteSelected_Content"], yesText: SharedLoc["Yes"], cancelText: SharedLoc["No"]);
        if (result == true)
        {
            var chaptersToDelete = selectedChapters.ToList();
            foreach (var c in chaptersToDelete)
            {
                await DeleteChapter(c.Chapter);
            }
        }
    }

    private async Task UpscaleSelectedChapters()
    {
        var chaptersToUpscale = selectedChapters.Where(c => !c.Chapter.IsUpscaled).ToList();
        foreach (var c in chaptersToUpscale)
        {
            await UpscaleChapter(c.Chapter);
        }
    }

    private async Task DeleteSelectedUpscaled()
    {
        var result = await DialogService.ShowMessageBox(Loc["Dialog_DeleteUpscaledSelected_Title"],
        Loc["Dialog_DeleteUpscaledSelected_Content"], SharedLoc["Yes"], cancelText: SharedLoc["No"]);
        if (result == true)
        {
            var chaptersToProcess = selectedChapters.ToList();
            foreach (var c in chaptersToProcess)
            {
                await DeleteUpscaled(c.Chapter);
            }
        }
    }

    private async Task RevertSelectedMergedChapters()
    {
        // Filter to only merged chapters from the selection
        var mergedChapters = selectedChapters.Where(c => c.IsMerged).ToList();

        if (!mergedChapters.Any())
        {
            Snackbar.Add(Loc["Snackbar_NoMergedSelected"], Severity.Warning);
            return;
        }

        var result = await DialogService.ShowMessageBox(
        Loc["Dialog_RevertSelectedMerged_Title"],
        string.Format(Loc["Dialog_RevertSelectedMerged_Content"],
        Loc["Word_MergedChapter"].Value.ToLocalizedQuantity(mergedChapters.Count, CultureInfo.CurrentUICulture)),
        SharedLoc["Yes"],
        cancelText: SharedLoc["No"]);

        if (result == true)
        {
            int successCount = 0;
            int failureCount = 0;

            foreach (var chapterItem in mergedChapters)
            {
                try
                {
                    await RevertMergedChapter(chapterItem.Chapter);
                    successCount++;
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to revert merged chapter {ChapterId}", chapterItem.Chapter.Id);
                    failureCount++;
                }
            }

            if (successCount > 0)
            {
                Snackbar.Add(string.Format(Loc["Snackbar_RevertMerged_Success"], successCount), Severity.Success);
            }

            if (failureCount > 0)
            {
                Snackbar.Add(string.Format(Loc["Snackbar_RevertMerged_Failure"], failureCount), Severity.Error);
            }

            // Update merge possibilities cache after revert operations
            await UpdateMergePossibilitiesAsync();
        }
    }

    private async Task DeleteChapterConfirm(Chapter chapter)
    {
        var result = await DialogService.ShowMessageBox(Loc["Dialog_DeleteChapter_Title"], Loc["Dialog_DeleteChapter_Content"],
        yesText: SharedLoc["Yes"], cancelText: SharedLoc["No"]);
        if (result == true)
        {
            await DeleteChapter(chapter);
        }
    }

    private async Task RevertMergedChapterConfirm(Chapter chapter)
    {
        var result = await DialogService.ShowMessageBox(
        Loc["Dialog_RevertMergedChapter_Title"],
        Loc["Dialog_RevertMergedChapter_Content"],
        SharedLoc["Yes"],
        cancelText: SharedLoc["No"]);

        if (result == true)
        {
            await RevertMergedChapter(chapter);
        }
    }

    private async Task RevertMergedChapter(Chapter chapter)
    {
        try
        {
            var restoredChapters = await ChapterMergeRevertService.RevertMergedChapterAsync(chapter);

            // Remove the merged chapter from the UI
            var chapterItem = chapterItems.FirstOrDefault(ci => ci.Chapter.Id == chapter.Id);
            if (chapterItem != null)
            {
                chapters.Remove(chapterItem);
            }

            // Add the restored chapters to the UI
            foreach (var restoredChapter in restoredChapters)
            {
                var extractedMetadata = await MetadataHandler.GetSeriesAndTitleFromComicInfoAsync(
                Path.Combine(Manga.Library.NotUpscaledLibraryPath, restoredChapter.RelativePath));

                chapters.Add(new ChapterItem
                {
                    Chapter = restoredChapter,
                    ExtractedMetadata = extractedMetadata,
                    NewTitle = extractedMetadata?.ChapterTitle ?? string.Empty,
                    NewFileName = Path.GetFileNameWithoutExtension(restoredChapter.FileName),
                    IsMerged = false // Restored chapters are not merged
                });

                try
                {
                    await ChapterChangedNotifier.Notify(restoredChapter, false);
                    if (restoredChapter.IsUpscaled)
                    {
                        await ChapterChangedNotifier.Notify(restoredChapter, true);
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to notify connected service of chapter change for merged chapter {ChapterId}",
                    restoredChapter.Id);
                    Snackbar.Add(string.Format(Loc["Snackbar_NotifyChange_Failure"], restoredChapter.FileName), Severity.Error);
                }
            }

            // Clear merge cache to ensure fresh recalculation
            InvalidateMergePossibilitiesCache();

            // Force UI update to ensure proper button state
            StateHasChanged();

            // Update merge possibilities cache since chapters changed
            await UpdateMergePossibilitiesAsync();

            Snackbar.Add(string.Format(Loc["Snackbar_RevertMergedChapter_Success"], restoredChapters.Count),
            Severity.Success);

            // Final UI refresh to ensure all button states are correct
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to revert merged chapter {ChapterId}", chapter.Id);
            Snackbar.Add(Loc["Snackbar_RevertMergedChapter_Failure"], Severity.Error);
        }
    }

    private async Task OnChapterMetadataCommit(ChapterItem? chapter)
    {
        if (chapter == null) return;

        if (chapter.ExtractedMetadata?.ChapterTitle != chapter.NewTitle)
        {
            await MangaMetadataChanger.ChangeChapterTitle(chapter.Chapter, chapter.NewTitle);
            if (chapter.ExtractedMetadata != null)
            {
                chapter.ExtractedMetadata = chapter.ExtractedMetadata with { ChapterTitle = chapter.NewTitle };
            }
        }

        if (Path.GetFileNameWithoutExtension(chapter.Chapter.FileName) != chapter.NewFileName)
        {
            if (!await RenameChapterFile(chapter.Chapter, chapter.NewFileName + ".cbz"))
            {
                chapter.NewFileName = Path.GetFileNameWithoutExtension(chapter.Chapter.FileName);
            }
        }
    }

    private void OnChapterMetadataDiscard(ChapterItem? chapter)
    {
        if (chapter == null) return;

        chapter.NewTitle = chapter.ExtractedMetadata?.ChapterTitle ?? string.Empty;
        chapter.NewFileName = Path.GetFileNameWithoutExtension(chapter.Chapter.FileName);
    }

    private async Task DeleteChapter(Chapter chapter)
    {
        await DeleteUpscaled(chapter);

        string toDelete = Path.Combine(Manga.Library.NotUpscaledLibraryPath, chapter.RelativePath);

        if (!File.Exists(toDelete))
        {
            return;
        }

        try
        {
            File.Delete(toDelete);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Failed to delete file of Chapter {ChapterId}", chapter.Id);
            Snackbar.Add(string.Format(Loc["Snackbar_DeleteFile_Failure"], chapter.FileName), Severity.Error);
        }

        DbContext.Remove(chapter);

        await DbContext.SaveChangesAsync();

        chapters.Remove(chapterItems.First(ci => ci.Chapter == chapter));

        // Invalidate merge possibilities cache since chapters changed
        InvalidateMergePossibilitiesCache();
    }

    private async Task UpscaleChapter(Chapter chapter)
    {
        if (chapter.IsUpscaled)
        {
            return;
        }

        if (!DbContext.Entry(Manga.Library).Reference(l => l.UpscalerProfile).IsLoaded)
        {
            await DbContext.Entry(Manga.Library).Reference(l => l.UpscalerProfile).LoadAsync();
        }

        if (!DbContext.Entry(Manga).Reference(m => m.UpscalerProfilePreference).IsLoaded)
        {
            await DbContext.Entry(Manga).Reference(m => m.UpscalerProfilePreference).LoadAsync();
        }

        if (Manga.EffectiveUpscalerProfile == null)
        {
            Snackbar.Add(Loc["Snackbar_UpscalerProfileNotSet"], Severity.Error);
            return;
        }

        await TaskQueue.EnqueueAsync(
        new UpscaleTask(chapter));
    }

    private async Task DeleteUpscaledConfirm(Chapter chapter)
    {
        var result = await DialogService.ShowMessageBox(Loc["Dialog_DeleteUpscaledChapter_Title"],
        Loc["Dialog_DeleteUpscaledChapter_Content"], yesText: SharedLoc["Yes"], cancelText: SharedLoc["No"]);
        if (result == true)
        {
            await DeleteUpscaled(chapter);
        }
    }

    private async Task DeleteUpscaled(Chapter chapter)
    {
        if (!chapter.IsUpscaled)
        {
            return;
        }

        if (string.IsNullOrEmpty(Manga.Library.UpscaledLibraryPath))
        {
            Snackbar.Add(Loc["Snackbar_UpscaledLibraryPathNotSet"], Severity.Error);
            return;
        }

        string toDelete = Path.Combine(Manga.Library.UpscaledLibraryPath, chapter.RelativePath);
        if (!File.Exists(toDelete))
        {
            return;
        }

        try
        {
            File.Delete(toDelete);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Failed to delete upscaled file of Chapter {ChapterId}", chapter.Id);
            Snackbar.Add(string.Format(Loc["Snackbar_DeleteUpscaledFile_Failure"], chapter.FileName), Severity.Error);
        }

        chapter.IsUpscaled = false;

        await DbContext.SaveChangesAsync();
    }

    private async Task<bool> RenameChapterFile(Chapter chapter, string newFileName)
    {
        // Check if the new name contains invalid characters
        if (newFileName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0)
        {
            Snackbar.Add(Loc["Snackbar_InvalidFileName"], Severity.Error);
            return false;
        }

        if (Manga?.Library == null) // Ensure Manga and Library are not null
        {
            Snackbar.Add(Loc["Snackbar_MissingInfo"], Severity.Error);
            return false;
        }

        if (string.IsNullOrEmpty(Manga.Library.UpscaledLibraryPath) && chapter.IsUpscaled)
        {
            Snackbar.Add(Loc["Snackbar_UpscaledPathNotSetButUpscaled"], Severity.Error);
            return false;
        }

        var mangaTitle = Manga.PrimaryTitle ?? "Unknown_Series";
        string oldPath = Path.Combine(chapter.Manga.Library.NotUpscaledLibraryPath, chapter.RelativePath);
        var targetRelativePath = Path.Combine(PathEscaper.EscapeFileName(mangaTitle), newFileName);
        string newPath = Path.Combine(chapter.Manga.Library.NotUpscaledLibraryPath, targetRelativePath);
        bool success = true;

        string? oldUpscaledPath = null;
        string? newUpscaledPath = null;

        try
        {
            FileSystem.Move(oldPath, newPath);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Failed to rename file of Chapter {ChapterId}", chapter.Id);
            Snackbar.Add(string.Format(Loc["Snackbar_RenameFile_Failure"], chapter.FileName), Severity.Error);
            success = false;
        }

        if (chapter.IsUpscaled && Manga?.Library?.UpscaledLibraryPath != null)
        {
            oldUpscaledPath = Path.Combine(Manga.Library.UpscaledLibraryPath, chapter.RelativePath);
            newUpscaledPath = Path.Combine(Manga.Library.UpscaledLibraryPath, targetRelativePath);
            if (success)
            {
                try
                {
                    FileSystem.Move(oldUpscaledPath, newUpscaledPath);
                }
                catch (Exception e)
                {
                    Logger.LogError(e, "Failed to rename upscaled file of Chapter {ChapterId}", chapter.Id);
                    Snackbar.Add(string.Format(Loc["Snackbar_RenameUpscaledFile_Failure"], chapter.FileName), Severity.Error);
                    success = false;
                    // Try to revert the rename of the not upscaled file
                    FileSystem.Move(newPath, oldPath);
                }
            }
        }

        if (success)
        {
            chapter.RelativePath = targetRelativePath;
            chapter.FileName = newFileName;
            await DbContext.SaveChangesAsync();
            _ = ChapterChangedNotifier.Notify(chapter, false);
            if (chapter.IsUpscaled)
            {
                _ = ChapterChangedNotifier.Notify(chapter, true);
            }
        }
        else
        {
            if (File.Exists(newPath))
            {
                try
                {
                    FileSystem.Move(newPath, oldPath);
                }
                catch (Exception e)
                {
                    Logger.LogError(e, "Failed to revert rename of file of Chapter {ChapterId}", chapter.Id);
                    Snackbar.Add(string.Format(Loc["Snackbar_RevertRename_Failure"], chapter.FileName), Severity.Error);
                }
            }

            if (File.Exists(newUpscaledPath) && newUpscaledPath != null && oldUpscaledPath != null)
            {
                try
                {
                    FileSystem.Move(newUpscaledPath, oldUpscaledPath);
                }
                catch (Exception e)
                {
                    Logger.LogError(e, "Failed to revert rename of upscaled file of Chapter {ChapterId}", chapter.Id);
                    Snackbar.Add(string.Format(Loc["Snackbar_RevertRenameUpscaled_Failure"], chapter.FileName),
                    Severity.Error);
                }
            }
        }

        return success;
    }

    protected override async Task OnInitializedAsync()
    {
        if (!DbContext.Entry(Manga).Collection(m => m.Chapters).IsLoaded)
        {
            await DbContext.Entry(Manga).Collection(m => m.Chapters).LoadAsync();
        }

        if (!DbContext.Entry(Manga).Reference(m => m.Library).IsLoaded)
        {
            await DbContext.Entry(Manga).Reference(m => m.Library).LoadAsync();
        }

        await LoadChapters();

        // Set up the reactive binding BEFORE updating merge cache so UI elements exist
        chapters.Connect()
        .Sort(new NaturalSortComparer<ChapterItem>(ci => ci.ExtractedMetadata?.ChapterTitle ?? string.Empty))
        .Bind(out chapterItems)
        .Subscribe();

        // Force initial cache update and UI state refresh to ensure merge buttons appear
        await ForceUpdateMergePossibilitiesAsync();

        _ = Task.Run(async () => { return await LibraryIntegrityChecker.CheckIntegrity(Manga); }).ContinueWith(async t =>
        {
            if (t.IsFaulted)
            {
                Logger.LogError(t.Exception, "Error checking library integrity for Manga ID {MangaId}", Manga?.Id);
                return;
            }

            if (t.Result) // t.Result is the boolean from CheckIntegrity
            {
                await InvokeAsync(async () =>
        {
            await LoadChapters();
            InvalidateMergePossibilitiesCache();
            await UpdateMergePossibilitiesAsync();
            StateHasChanged();
        });
            }
        }, TaskScheduler.FromCurrentSynchronizationContext());
    }

    private async Task<bool> LoadChapters()
    {
        bool loadingFailed = false;
        chapters.Clear();
        if (Manga.Chapters == null)
        {
            Logger.LogWarning("Chapters is null in LoadChapters for Manga ID {MangaId}.", Manga.Id);
            return true;
        }

        var splitStates = await DbContext.ChapterSplitProcessingStates
        .Where(s => s.Chapter.MangaId == Manga.Id)
        .ToDictionaryAsync(s => s.ChapterId);

        var splitFindingsCounts = await DbContext.StripSplitFindings
        .Where(f => f.Chapter.MangaId == Manga.Id)
        .GroupBy(f => f.ChapterId)
        .Select(g => new { ChapterId = g.Key, Count = g.Count() })
        .ToDictionaryAsync(x => x.ChapterId, x => x.Count);

        foreach (var chapter in Manga.Chapters.ToList()) // ToList() を追加して、コレクションの変更を許可します
        {
            var loadProfile = Task.FromResult(chapter.UpscalerProfile);
            if (chapter.UpscalerProfileId is not null && chapter.UpscalerProfile is null)
            {
                // The following is used to ignore soft deleted profiles
                loadProfile = DbContext.UpscalerProfiles.IgnoreQueryFilters()
                .FirstOrDefaultAsync(p => p.Id == chapter.UpscalerProfileId);
            }

            try
            {
                if (Manga.Library?.NotUpscaledLibraryPath == null)
                {
                    loadingFailed = true;
                    continue;
                }

                if (string.IsNullOrEmpty(chapter.RelativePath))
                {
                    Logger.LogWarning("Chapter {ChapterId} has null or empty RelativePath.", chapter.Id);
                    loadingFailed = true;
                    continue;
                }

                var extractedMetadata = await
                MetadataHandler.GetSeriesAndTitleFromComicInfoAsync(Path.Combine(Manga.Library.NotUpscaledLibraryPath,
                chapter.RelativePath));
                chapter.UpscalerProfile = await loadProfile;

                // Check if this chapter is a merged chapter
                var isMerged = await ChapterMergeRevertService.CanRevertChapterAsync(chapter);

                Logger.LogDebug("LoadChapters: Chapter {FileName} (ID: {ChapterId}) - IsMerged: {IsMerged}",
                chapter.FileName, chapter.Id, isMerged);

                chapters.Add(new ChapterItem
                {
                    Chapter = chapter,
                    ExtractedMetadata = extractedMetadata,
                    NewTitle = extractedMetadata?.ChapterTitle ?? string.Empty,
                    NewFileName = Path.GetFileNameWithoutExtension(chapter.FileName),
                    IsMerged = isMerged,
                    SplitState = splitStates.GetValueOrDefault(chapter.Id),
                    SplitFindingsCount = splitFindingsCounts.GetValueOrDefault(chapter.Id)
                });
            }
            catch (Exception e)
            {
                Logger.LogError(e, "Failed to load metadata for Chapter {ChapterId}", chapter.Id);
                Snackbar.Add(string.Format(Loc["Snackbar_LoadMetadata_Failure"], chapter.FileName), Severity.Error);
                loadingFailed = true;
                continue;
            }
        }

        return loadingFailed;
    }

    // Manual merge functionality
    private bool CanAnySelectedBeMerged
    {
        get
        {
            // Must have chapters selected and none of them should be merged
            if (!selectedChapters.Any() || selectedChapters.Any(c => c.IsMerged))
                return false;

            // Use cached merge possibilities if available
            return _cachedMergePossibilities?.HasAnyMergePossibilities == true;
        }
    }

    private bool CanManualMergeSelected => selectedChapters.Any() && !selectedChapters.Any(c => c.IsMerged);

    private bool CanManualMergeChapterSync(Chapter chapter)
    {
        // Check cached possibilities for this specific chapter
        if (_cachedMergePossibilities == null)
            return false;

        // Check if this chapter can form new merge groups
        bool canFormNewMerge = _cachedMergePossibilities.NewMergeGroups.Values
        .Any(chapterList => chapterList.Any(c => c.Id == chapter.Id));

        // Check if this chapter can be added to existing merged chapters
        bool canAddToExisting = _cachedMergePossibilities.AdditionsToExistingMerged.Values
        .Any(chapterList => chapterList.Any(c => c.Id == chapter.Id));

        return canFormNewMerge || canAddToExisting;
    }

    // Cache for merge possibilities to avoid repeated async calls during UI rendering
    private MergeActionInfo? _cachedMergePossibilities;
    private DateTime _lastMergePossibilitiesUpdate = DateTime.MinValue;
    private readonly TimeSpan _mergePossibilitiesCacheTimeout = TimeSpan.FromSeconds(5); // Increased timeout for debugging

    private void InvalidateMergePossibilitiesCache()
    {
        _cachedMergePossibilities = null;
        _lastMergePossibilitiesUpdate = DateTime.MinValue;
        Logger.LogDebug("InvalidateMergePossibilitiesCache: Cache invalidated for manga {MangaId}", Manga?.Id);
    }

    private async Task ForceUpdateMergePossibilitiesAsync()
    {
        Logger.LogDebug("ForceUpdateMergePossibilitiesAsync: Forcing cache update for manga {MangaId}", Manga?.Id);
        InvalidateMergePossibilitiesCache();
        await UpdateMergePossibilitiesAsync();
        StateHasChanged();
    }

    private async Task UpdateMergePossibilitiesAsync()
    {
        if (DateTime.UtcNow - _lastMergePossibilitiesUpdate < _mergePossibilitiesCacheTimeout)
        {
            Logger.LogDebug("UpdateMergePossibilitiesAsync: Skipping update, cache still valid (age: {Age}ms)",
            (DateTime.UtcNow - _lastMergePossibilitiesUpdate).TotalMilliseconds);
            return;
        }

        Logger.LogDebug("UpdateMergePossibilitiesAsync: Starting cache update for manga {MangaId}", Manga?.Id);

        try
        {
            Logger.LogDebug("UpdateMergePossibilitiesAsync: Total chapter items: {TotalCount}", chapterItems.Count);
            foreach (var ci in chapterItems)
            {
                Logger.LogDebug("UpdateMergePossibilitiesAsync: Chapter {FileName} (ID: {ChapterId}) - IsMerged: {IsMerged}",
                ci.Chapter.FileName, ci.Chapter.Id, ci.IsMerged);
            }

            var allChapters = chapterItems.Where(ci => !ci.IsMerged).Select(ci => ci.Chapter).ToList();
            Logger.LogDebug("UpdateMergePossibilitiesAsync: Found {ChapterCount} non-merged chapters: [{ChapterNames}]",
            allChapters.Count, string.Join(", ", allChapters.Select(c => c.FileName)));

            if (allChapters.Any())
            {
                Logger.LogDebug("UpdateMergePossibilitiesAsync: Calling GetPossibleMergeActionsAsync with {ChapterCount} chapters",
                allChapters.Count);
                _cachedMergePossibilities = await ChapterMergeCoordinator.GetPossibleMergeActionsAsync(allChapters,
                includeLatestChapters: true);

                Logger.LogDebug("Updated merge possibilities cache: {NewMergeGroups} new merge groups, {AdditionsToExisting} additions to existing, HasAnyMergePossibilities: {HasAny}",
                _cachedMergePossibilities.NewMergeGroups.Count, _cachedMergePossibilities.AdditionsToExistingMerged.Count,
                _cachedMergePossibilities.HasAnyMergePossibilities);

                // Log detailed merge group information
                foreach (var (baseNumber, chapterList) in _cachedMergePossibilities.NewMergeGroups)
                {
                    Logger.LogDebug("New merge group {BaseNumber}: [{ChapterNames}]",
                    baseNumber, string.Join(", ", chapterList.Select(c => c.FileName)));
                }

                foreach (var (baseNumber, chapterList) in _cachedMergePossibilities.AdditionsToExistingMerged)
                {
                    Logger.LogDebug("Addition to existing merged {BaseNumber}: [{ChapterNames}]",
                    baseNumber, string.Join(", ", chapterList.Select(c => c.FileName)));
                }
            }
            else
            {
                _cachedMergePossibilities = new MergeActionInfo();
                Logger.LogDebug("No non-merged chapters found, created empty merge possibilities cache");
            }

            _lastMergePossibilitiesUpdate = DateTime.UtcNow;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update merge possibilities cache");
            _cachedMergePossibilities = new MergeActionInfo();
        }
    }

    private bool SharesSameBaseNumber(string fileName1, string fileName2)
    {
        // Simple heuristic: check if both have same numeric prefix
        var num1 = ExtractNumericPrefix(fileName1);
        var num2 = ExtractNumericPrefix(fileName2);
        return !string.IsNullOrEmpty(num1) && !string.IsNullOrEmpty(num2) &&
        Math.Floor(decimal.Parse(num1)) == Math.Floor(decimal.Parse(num2));
    }

    private string? ExtractNumericPrefix(string fileName)
    {
        var match = Regex.Match(fileName, @"(\d+(?:\.\d+)?)");
        return match.Success ? match.Groups[1].Value : null;
    }

    private async Task MergeSelectedChapters()
    {
        if (!selectedChapters.Any())
        {
            Snackbar.Add(Loc["Snackbar_NoChaptersSelected"], Severity.Warning);
            return;
        }

        // Filter to only non-merged chapters from the selection
        var selectedChapterList = selectedChapters.Where(c => !c.IsMerged).Select(ci => ci.Chapter).ToList();

        if (!selectedChapterList.Any())
        {
            Snackbar.Add(Loc["Snackbar_NoNonMergedSelected"], Severity.Warning);
            return;
        }

        // Get possible merge actions for the selected chapters
        var mergeActionsWithoutLatest = await ChapterMergeCoordinator.GetPossibleMergeActionsAsync(
        selectedChapterList,
        includeLatestChapters: false);

        var mergeActionsWithLatest = await ChapterMergeCoordinator.GetPossibleMergeActionsAsync(
        selectedChapterList,
        includeLatestChapters: true);

        if (!mergeActionsWithLatest.HasAnyMergePossibilities)
        {
            Snackbar.Add(Loc["Snackbar_NoValidMergeOperations"], Severity.Warning);
            return;
        }

        bool includeLatest = true;

        // If there's a difference, ask the user about latest chapters
        var totalActionsWithoutLatest = mergeActionsWithoutLatest.NewMergeGroups.Count +
        mergeActionsWithoutLatest.AdditionsToExistingMerged.Count;
        var totalActionsWithLatest = mergeActionsWithLatest.NewMergeGroups.Count +
        mergeActionsWithLatest.AdditionsToExistingMerged.Count;

        if (totalActionsWithLatest > totalActionsWithoutLatest)
        {
            var result = await DialogService.ShowMessageBox(
            Loc["Dialog_LatestChapter_Title"],
            Loc["Dialog_LatestChapter_Content"],
            SharedLoc["Yes"], SharedLoc["No"]);

            if (result != true)
                return;
        }

        await PerformMergeOperations(mergeActionsWithLatest, includeLatest);
    }

    private async Task MergeChapterConfirm(Chapter chapter)
    {
        // Get all chapters in the series to properly identify merge actions
        var allChapters = chapterItems.Where(ci => !ci.IsMerged).Select(ci => ci.Chapter).ToList();
        var mergeActions = await ChapterMergeCoordinator.GetPossibleMergeActionsAsync(
        allChapters,
        includeLatestChapters: true);

        if (!mergeActions.HasAnyMergePossibilities)
        {
            Snackbar.Add(Loc["Snackbar_NoMergeOperationsForChapter"], Severity.Warning);
            return;
        }

        // Find which merge action contains this chapter
        List<Chapter>? chaptersToMerge = null;
        string? mergeType = null;
        string? baseNumber = null;

        // Check if it's part of a new merge group
        foreach (var (baseNum, chapterList) in mergeActions.NewMergeGroups)
        {
            if (chapterList.Any(c => c.Id == chapter.Id))
            {
                chaptersToMerge = chapterList;
                mergeType = "new merge";
                baseNumber = baseNum;
                break;
            }
        }

        // Check if it can be added to an existing merged chapter
        if (chaptersToMerge == null)
        {
            foreach (var (baseNum, chapterList) in mergeActions.AdditionsToExistingMerged)
            {
                if (chapterList.Any(c => c.Id == chapter.Id))
                {
                    chaptersToMerge = chapterList;
                    mergeType = "addition to existing merged chapter";
                    baseNumber = baseNum;
                    break;
                }
            }
        }

        if (chaptersToMerge == null || baseNumber == null)
        {
            Snackbar.Add(Loc["Snackbar_ChapterNotMergeable"], Severity.Warning);
            return;
        }

        // Check if latest chapter is involved
        var mergeActionsWithoutLatest = await ChapterMergeCoordinator.GetPossibleMergeActionsAsync(
        chaptersToMerge,
        includeLatestChapters: false);

        bool includeLatest = true;
        var hasActionsWithoutLatest = mergeActionsWithoutLatest.NewMergeGroups.ContainsKey(baseNumber) ||
        mergeActionsWithoutLatest.AdditionsToExistingMerged.ContainsKey(baseNumber);

        if (!hasActionsWithoutLatest)
        {
            var result = await DialogService.ShowMessageBox(
            Loc["Dialog_LatestChapter_Title"],
            string.Format(Loc["Dialog_LatestChapterSpecific_Content"], mergeType, baseNumber),
            SharedLoc["Yes"], SharedLoc["No"]);

            if (result != true)
                return;
        }

        if (mergeType == "addition to existing merged chapter")
        {
            await PerformAdditionToExistingMerged(chaptersToMerge, baseNumber);
        }
        else
        {
            await PerformMergeOperation(chaptersToMerge, includeLatest);
        }
    }

    private async Task PerformMergeOperation(List<Chapter> chaptersToMerge, bool includeLatestChapters)
    {
        try
        {
            var completedMerges = await ChapterMergeCoordinator.MergeSelectedChaptersAsync(
            chaptersToMerge,
            includeLatestChapters);

            if (!completedMerges.Any())
            {
                Snackbar.Add(Loc["Snackbar_NoChaptersMerged"], Severity.Warning);
                return;
            }

            int totalProcessedChapters = 0;

            // Update UI: Remove original chapters and add merged chapters
            foreach (var mergeInfo in completedMerges)
            {
                // Remove ALL the original chapters from the UI (we'll add the updated merged chapter below)
                var originalChapterIds = chaptersToMerge.Select(c => c.Id).ToHashSet();

                var itemsToRemove = chapterItems.Where(ci => originalChapterIds.Contains(ci.Chapter.Id)).ToList();
                foreach (var item in itemsToRemove)
                {
                    chapters.Remove(item);
                    totalProcessedChapters++;
                }

                // Find the merged chapter from the database - it should be the FIRST chapter from the original set
                // (as per ChapterMergeCoordinator.UpdateDatabaseForMergeAsync which keeps the first and removes the rest)
                var primaryChapterId = chaptersToMerge.First().Id;
                var mergedChapter = await DbContext.Chapters.FindAsync(primaryChapterId);
                if (mergedChapter != null)
                {
                    // Reload the chapter to get updated data
                    await DbContext.Entry(mergedChapter).ReloadAsync();

                    var extractedMetadata = await MetadataHandler.GetSeriesAndTitleFromComicInfoAsync(
                    Path.Combine(Manga.Library.NotUpscaledLibraryPath, mergedChapter.RelativePath));

                    // Properly determine if the chapter is merged by checking the database
                    var isMerged = await ChapterMergeRevertService.CanRevertChapterAsync(mergedChapter);

                    chapters.Add(new ChapterItem
                    {
                        Chapter = mergedChapter,
                        ExtractedMetadata = extractedMetadata,
                        NewTitle = extractedMetadata?.ChapterTitle ?? string.Empty,
                        NewFileName = Path.GetFileNameWithoutExtension(mergedChapter.FileName),
                        IsMerged = isMerged
                    });

                    try
                    {
                        await ChapterChangedNotifier.Notify(mergedChapter, false);
                        if (mergedChapter.IsUpscaled)
                        {
                            await ChapterChangedNotifier.Notify(mergedChapter, true);
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Failed to notify connected service of chapter change for merged chapter {ChapterId}",
                        mergedChapter.Id);
                        Snackbar.Add(string.Format(Loc["Snackbar_NotifyChange_Failure"], mergedChapter.FileName), Severity.Error);
                    }
                }
            }

            var message = completedMerges.Count == 1
            ? string.Format(Loc["Snackbar_MergeSuccess_Single"], totalProcessedChapters)
            : string.Format(Loc["Snackbar_MergeSuccess_Multiple"], totalProcessedChapters, completedMerges.Count);

            // Clear merge cache to ensure fresh recalculation
            InvalidateMergePossibilitiesCache();

            // Force UI update to ensure proper button state
            StateHasChanged();

            // Update merge possibilities cache after successful merge
            await UpdateMergePossibilitiesAsync();

            Snackbar.Add(message, Severity.Success);

            // Final UI refresh to ensure all button states are correct
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to perform manual merge operations");
            Snackbar.Add(Loc["Snackbar_MergeFailure"], Severity.Error);
        }
    }

    private async Task PerformMergeOperations(MergeActionInfo mergeActions, bool includeLatestChapters)
    {
        try
        {
            int totalNewMerges = 0;
            int totalAdditions = 0;

            // Handle new merges first
            foreach (var (baseNumber, chapterList) in mergeActions.NewMergeGroups)
            {
                await PerformMergeOperation(chapterList, includeLatestChapters);
                totalNewMerges++;
            }

            // Handle additions to existing merged chapters
            foreach (var (baseNumber, chapterList) in mergeActions.AdditionsToExistingMerged)
            {
                await PerformAdditionToExistingMerged(chapterList, baseNumber);
                totalAdditions++;
            }

            // Update merge possibilities cache
            await UpdateMergePossibilitiesAsync();

            var message = "";
            if (totalNewMerges > 0 && totalAdditions > 0)
            {
                message = string.Format(Loc["Snackbar_MergeOperationsSuccess_Both"], totalNewMerges, totalAdditions);
            }
            else if (totalNewMerges > 0)
            {
                message = string.Format(Loc["Snackbar_MergeOperationsSuccess_New"], totalNewMerges);
            }
            else if (totalAdditions > 0)
            {
                message = string.Format(Loc["Snackbar_MergeOperationsSuccess_Add"], totalAdditions);
            }

            if (!string.IsNullOrEmpty(message))
            {
                Snackbar.Add(message, Severity.Success);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to perform merge operations");
            Snackbar.Add(Loc["Snackbar_MergeOperationsFailure"], Severity.Error);
        }
    }

    private async Task PerformAdditionToExistingMerged(List<Chapter> chaptersToAdd, string baseNumber)
    {
        try
        {
            // Use the chapter merging coordinator to add chapters to existing merged chapter
            await ChapterMergeCoordinator.ProcessExistingChapterPartsForMergingAsync(Manga);

            // Remove the added chapters from UI since they're now part of the merged chapter
            foreach (var chapter in chaptersToAdd)
            {
                var chapterItem = chapterItems.FirstOrDefault(ci => ci.Chapter.Id == chapter.Id);
                if (chapterItem != null)
                {
                    chapters.Remove(chapterItem);
                }
            }

            // Find and update the merged chapter in the UI
            var mergedChapter = Manga.Chapters.FirstOrDefault(c =>
            chapterItems.Any(ci => ci.Chapter.Id == c.Id && ci.IsMerged) &&
            c.FileName.StartsWith(baseNumber + ".") || c.FileName == baseNumber + ".cbz");

            if (mergedChapter != null)
            {
                // Reload the merged chapter to get updated data
                await DbContext.Entry(mergedChapter).ReloadAsync();

                var existingItem = chapterItems.FirstOrDefault(ci => ci.Chapter.Id == mergedChapter.Id);
                if (existingItem != null)
                {
                    // Update the existing item
                    var extractedMetadata = await MetadataHandler.GetSeriesAndTitleFromComicInfoAsync(
                    Path.Combine(Manga.Library.NotUpscaledLibraryPath, mergedChapter.RelativePath));

                    existingItem.ExtractedMetadata = extractedMetadata;
                    existingItem.NewTitle = extractedMetadata?.ChapterTitle ?? string.Empty;
                    existingItem.NewFileName = Path.GetFileNameWithoutExtension(mergedChapter.FileName);

                    try
                    {
                        await ChapterChangedNotifier.Notify(mergedChapter, false);
                        if (mergedChapter.IsUpscaled)
                        {
                            await ChapterChangedNotifier.Notify(mergedChapter, true);
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Failed to notify connected service of chapter change for updated merged chapter {ChapterId}",
                        mergedChapter.Id);
                        Snackbar.Add(string.Format(Loc["Snackbar_NotifyChange_Failure"], mergedChapter.FileName), Severity.Error);
                    }
                }
            }

            // Update merge possibilities cache after successful addition
            await UpdateMergePossibilitiesAsync();

            Snackbar.Add(string.Format(Loc["Snackbar_AddChaptersSuccess"], chaptersToAdd.Count, baseNumber),
            Severity.Success);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to add chapters to existing merged chapter {BaseNumber}", baseNumber);
            Snackbar.Add(string.Format(Loc["Snackbar_AddChaptersFailure"], baseNumber),
            Severity.Error);
        }
    }

    private async Task DetectSplits(Chapter chapter)
    {
        try
        {
            bool queued = await SplitProcessingCoordinator.EnqueueDetectionIfPlausibleAsync(chapter.Id);
            if (queued)
            {
                Snackbar.Add(string.Format(Loc["Snackbar_SplitDetectionQueued"], chapter.FileName), Severity.Success);
            }
            else
            {
                Snackbar.Add(string.Format(Loc["Snackbar_SplitDetectionCompleted"], chapter.FileName), Severity.Success);
            }

            // Reload chapters to reflect the new state (either Detected immediately or Pending)
            await LoadChapters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to queue split detection for chapter {ChapterId}", chapter.Id);
            Snackbar.Add(string.Format(Loc["Snackbar_SplitDetectionFailure"], ex.Message), Severity.Error);
        }
    }

    private async Task ViewSplits(Chapter chapter)
    {
        var parameters = new DialogParameters
{
{ "ChapterId", chapter.Id }
};

        var options = new DialogOptions { MaxWidth = MaxWidth.ExtraLarge, FullWidth = true, CloseButton = true };

        var dialog = await DialogService.ShowAsync<SplitEditorDialog>(Loc["Dialog_EditSplits_Title"], parameters, options);
        var result = await dialog.Result;
    }

    private async Task ApplySplits(Chapter chapter)
    {
        var result = await DialogService.ShowMessageBox(
        Loc["Dialog_ApplySplits_Title"],
        Loc["Dialog_ApplySplits_Content"],
        SharedLoc["Yes"],
        cancelText: SharedLoc["No"]);

        if (result == true)
        {
            try
            {
                await SplitApplicationService.ApplySplitsAsync(chapter.Id, SplitDetectionService.CURRENT_DETECTOR_VERSION,
                CancellationToken.None);
                Snackbar.Add(string.Format(Loc["Snackbar_SplitApplicationQueued"], chapter.FileName), Severity.Success);

                // Reset the state using the state manager
                await SplitStateManager.ResetToPendingAsync(chapter.Id, null, CancellationToken.None);

                // Refresh the UI
                var item = chapters.Items.FirstOrDefault(ci => ci.Chapter.Id == chapter.Id);
                if (item != null && item.SplitState != null)
                {
                    item.SplitState.Status = SplitProcessingStatus.Pending;

                    var index = chapters.Items.IndexOf(item);
                    if (index != -1)
                    {
                        chapters.ReplaceAt(index, item);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to apply splits for chapter {ChapterId}", chapter.Id);
                Snackbar.Add(string.Format(Loc["Snackbar_SplitApplicationFailure"], ex.Message), Severity.Error);
            }
        }
    }

    private record ChapterItem
    {
        public required Chapter Chapter { get; set; }
        public ExtractedMetadata? ExtractedMetadata { get; set; }
        public required string NewTitle { get; set; }
        public required string NewFileName { get; set; }
        public bool IsMerged { get; set; }
        public ChapterSplitProcessingState? SplitState { get; set; }
        public int SplitFindingsCount { get; set; }
    }

}