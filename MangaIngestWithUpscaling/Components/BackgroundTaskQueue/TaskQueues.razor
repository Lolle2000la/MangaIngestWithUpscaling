@using System.Collections.Specialized
@using MangaIngestWithUpscaling.Data.BackqroundTaskQueue
@using MangaIngestWithUpscaling.Services.BackqroundTaskQueue
@implements IDisposable

@inject ILogger<TaskQueues> Logger
@inject ISnackbar Snackbar

@inject TaskQueue TaskQueue
@inject StandardTaskProcessor StandardTaskProcessor
@inject UpscaleTaskProcessor UpscaleTaskProcessor
@inject DistributedUpscaleTaskProcessor DistributedUpscaleTaskProcessor
@inject TaskRegistry TaskRegistry

@page "/tasks"

<PageTitle>Tasks</PageTitle>

<MudText Typo="Typo.h4" Class="mb-2">Currently running tasks</MudText>

<MudGrid>
    <MudItem lg="6" xs="12">
        <TaskTable Tasks="@standardTasks" Title="Standard Tasks" OnClearCompleted="OnClearCompletedStandardTasks"
            OnClearFailed="OnClearFailedStandardTasks" OnRetryFailed="OnRetryFailed" OnDelete="OnDelete"
            OnCancel="OnCancelStandardTask" OnRunNow="OnRunNow" />
    </MudItem>
    <MudItem lg="6" xs="12">
        <TaskTable Tasks="@upscaleTasks" Title="Upscaling Tasks" OnClearCompleted="OnClearCompletedUpscaleTasks"
            OnClearFailed="OnClearFailedUpscaleTasks" OnRetryFailed="OnRetryFailed" OnDelete="OnDelete"
            OnCancel="OnCancelUpscaleTask" OnRunNow="OnRunNow" />
    </MudItem>
</MudGrid>

@code {
    private IReadOnlyCollection<PersistedTask> standardTasks => TaskRegistry.StandardTasks;
    private IReadOnlyCollection<PersistedTask> upscaleTasks => TaskRegistry.UpscaleTasks;

    private async Task OnClearCompletedStandardTasks()
    {
        try
        {
            var completedTasks = standardTasks.Where(x => x.Status == PersistedTaskStatus.Completed).ToList();
            foreach (var task in completedTasks)
            {
                await TaskQueue.RemoveTaskAsync(task);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to clear completed tasks");
            Snackbar.Add("Failed to clear completed tasks: " + ex.Message, Severity.Error);
            StateHasChanged();
        }
    }

    private async Task OnClearFailedStandardTasks()
    {
        try
        {
            var failedTasks = standardTasks.Where(x => x.Status == PersistedTaskStatus.Failed).ToList();
            foreach (var task in failedTasks)
            {
                await TaskQueue.RemoveTaskAsync(task);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to clear failed tasks");
            Snackbar.Add("Failed to clear failed tasks: " + ex.Message, Severity.Error);
            StateHasChanged();
        }
    }

    private async Task OnClearCompletedUpscaleTasks()
    {
        try
        {
            var completedTasks = upscaleTasks.Where(x => x.Status == PersistedTaskStatus.Completed).ToList();
            foreach (var task in completedTasks)
            {
                await TaskQueue.RemoveTaskAsync(task);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to clear completed tasks");
            Snackbar.Add("Failed to clear completed tasks: " + ex.Message, Severity.Error);
            StateHasChanged();
        }
    }

    private async Task OnClearFailedUpscaleTasks()
    {
        try
        {
            var failedTasks = upscaleTasks.Where(x => x.Status == PersistedTaskStatus.Failed).ToList();
            foreach (var task in failedTasks)
            {
                await TaskQueue.RemoveTaskAsync(task);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to clear failed tasks");
            Snackbar.Add("Failed to clear failed tasks: " + ex.Message, Severity.Error);
            StateHasChanged();
        }
    }

    private async Task OnRetryFailed(PersistedTask task)
    {
        try
        {
            await TaskQueue.RetryAsync(task);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to retry task {TaskId}", task.Id);
            Snackbar.Add("Failed to retry task: " + ex.Message, Severity.Error);
            StateHasChanged();
        }
    }

    private async Task OnDelete(PersistedTask task)
    {
        try
        {
            await TaskQueue.RemoveTaskAsync(task);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to delete task {TaskId}", task.Id);
            Snackbar.Add("Failed to delete task: " + ex.Message, Severity.Error);
            StateHasChanged();
        }
    }

    private Task OnCancelStandardTask(PersistedTask task)
    {
        try
        {
            StandardTaskProcessor.CancelCurrent(task);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to cancel task {TaskId}", task.Id);
            Snackbar.Add("Failed to cancel task: " + ex.Message, Severity.Error);
            StateHasChanged();
        }

        return Task.CompletedTask;
    }

    private async Task OnCancelUpscaleTask(PersistedTask task)
    {
        try
        {
            UpscaleTaskProcessor.CancelCurrent(task);
            await DistributedUpscaleTaskProcessor.CancelCurrent(task);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to cancel task {TaskId}", task.Id);
            Snackbar.Add("Failed to cancel task: " + ex.Message, Severity.Error);
            StateHasChanged();
        }
    }

    private async Task OnRunNow(PersistedTask task)
    {
        await TaskQueue.MoveToFrontAsync(task);
    }

    protected override Task OnInitializedAsync()
    {
        TaskQueue.TaskEnqueuedOrChanged += OnTaskUpdate;
        TaskQueue.TaskRemoved += OnTaskRemoved;
        StandardTaskProcessor.StatusChanged += OnStandardTaskChanged;
        UpscaleTaskProcessor.StatusChanged += OnUpscaleTaskChanged;
        DistributedUpscaleTaskProcessor.StatusChanged += OnUpscaleTaskChanged;

        // Also listen to registry collection changes to repaint when order or membership changes
        if (TaskRegistry.StandardTasks is INotifyCollectionChanged std)
            std.CollectionChanged += OnRegistryCollectionChanged;
        if (TaskRegistry.UpscaleTasks is INotifyCollectionChanged up)
            up.CollectionChanged += OnRegistryCollectionChanged;
        return Task.CompletedTask;
    }

    public void Dispose()
    {
        TaskQueue.TaskEnqueuedOrChanged -= OnTaskUpdate;
        TaskQueue.TaskRemoved -= OnTaskRemoved;
        StandardTaskProcessor.StatusChanged -= OnStandardTaskChanged;
        UpscaleTaskProcessor.StatusChanged -= OnUpscaleTaskChanged;
        DistributedUpscaleTaskProcessor.StatusChanged -= OnUpscaleTaskChanged;

        if (TaskRegistry.StandardTasks is INotifyCollectionChanged std)
            std.CollectionChanged -= OnRegistryCollectionChanged;
        if (TaskRegistry.UpscaleTasks is INotifyCollectionChanged up)
            up.CollectionChanged -= OnRegistryCollectionChanged;
    }

    private async Task OnTaskUpdate(PersistedTask task)
    {
        await InvokeAsync(() =>
        {
            // Registry drives the state; we only trigger UI refresh
            StateHasChanged();
            return Task.CompletedTask;
        });
    }

    private async Task OnStandardTaskChanged(PersistedTask task)
    {
        await InvokeAsync(() =>
        {
            // Registry drives the state; we only trigger UI refresh
            StateHasChanged();
            return Task.CompletedTask;
        });
    }

    private async Task OnUpscaleTaskChanged(PersistedTask task)
    {
        await InvokeAsync(() =>
        {
            // Registry drives the state; we only trigger UI refresh
            StateHasChanged();
            return Task.CompletedTask;
        });
    }

    private async Task OnTaskRemoved(PersistedTask task)
    {
        await InvokeAsync(() =>
        {
            StateHasChanged();
            return Task.CompletedTask;
        });
    }

    private void OnRegistryCollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        _ = InvokeAsync(StateHasChanged);
    }

    // No local collections; TaskRegistry is the single source of truth.
}
