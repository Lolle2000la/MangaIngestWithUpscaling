@using MangaIngestWithUpscaling.Data.BackgroundTaskQueue
@using System.Web
@inject NavigationManager NavigationManager

<MudTable T="PersistedTask" ServerData="@LoadTasks" RowsPerPage="10" Elevation="3" Dense="true" @ref="Table">
    <ToolBarContent>
        <MudText Typo="Typo.h6">@Title</MudText>
        <MudSpacer/>
        <MudButton StartIcon="@Icons.Material.Filled.Delete" Variant="Variant.Outlined" Color="Color.Primary"
                   OnClick="OnClearFailed">Clear Failed
        </MudButton>
        <MudButton StartIcon="@Icons.Material.Filled.ClearAll" Variant="Variant.Filled" Color="Color.Primary"
                   OnClick="OnClearCompleted">Clear Completed
        </MudButton>
    </ToolBarContent>
    <HeaderContent>
        <MudTh>
            <MudTableSortLabel T="PersistedTask" SortLabel="order_field" InitialDirection="SortDirection.Ascending">
                Order
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel T="PersistedTask" SortLabel="name_field">Name
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel T="PersistedTask" SortLabel="queued_field">Queued At</MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel T="PersistedTask" SortLabel="finished_field">Finished At
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel T="PersistedTask" SortLabel="status_field">Status</MudTableSortLabel>
        </MudTh>
        <MudTh>Actions</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="Order">
            @context.Order
        </MudTd>
        <MudTd DataLabel="Name">@context.Data.TaskFriendlyName</MudTd>
        <MudTd DataLabel="Queued At">@context.CreatedAt.ToLocalTime()</MudTd>
        <MudTd DataLabel="Finished At">@(context.ProcessedAt is not null ? context.ProcessedAt.Value.ToLocalTime() : "")
        </MudTd>
        <MudTd DataLabel="Status">
            @context.Status
            @if (context.Status == PersistedTaskStatus.Processing && context.Data?.Progress is not null)
            {
                var p = context.Data.Progress;
                <div style="font-size: 0.85em; color: var(--mud-palette-text-secondary); margin-top: 2px;">
                    @(p.IsIndeterminate ? "Working…" : $"{p.Current}/{p.Total} {p.ProgressUnit}")
                    @if (!string.IsNullOrWhiteSpace(p.StatusMessage))
                    {
                        <span> — @p.StatusMessage</span>
                    }
                </div>
            }
        </MudTd>
        <MudTd DataLabel="Actions" Style="white-space: nowrap">
            @if (context.Status == PersistedTaskStatus.Pending)
            {
                <MudIconButton Icon="@Icons.Material.Filled.PlayArrow" Variant="Variant.Text" Size="Size.Small"
                               OnClick="_ => OnRunNow.InvokeAsync(context)"/>
            }
            else if (context.Status is PersistedTaskStatus.Failed or PersistedTaskStatus.Canceled)
            {
                <MudIconButton Icon="@Icons.Material.Filled.Refresh" Variant="Variant.Text" Size="Size.Small"
                               OnClick="_ => OnRetryFailed.InvokeAsync(context)"/>
            }
            @if (context.Status == PersistedTaskStatus.Processing)
            {
                <MudIconButton Icon="@Icons.Material.Filled.Cancel" Variant="Variant.Text" Color="Color.Error"
                               Size="Size.Small" OnClick="_ => OnCancel.InvokeAsync(context)"/>
            }
            else
            {
                <MudIconButton Icon="@Icons.Material.Filled.Delete" Variant="Variant.Text" Color="Color.Error"
                               Size="Size.Small" OnClick="_ => OnDelete.InvokeAsync(context)"/>
            }
        </MudTd>
    </RowTemplate>
    <ChildRowContent>
        @if (context.Status == PersistedTaskStatus.Processing)
        {
            var p = context.Data?.Progress;
            <MudTd colspan="6" Class="pa-0">
                <div style="width: 100%; height: 4px;">
                    @if (p is null || p.IsIndeterminate || p.Total <= 0)
                    {
                        <MudProgressLinear Indeterminate="true" Color="Color.Primary" Style="height: 4px;"/>
                    }
                    else
                    {
                        <MudProgressLinear Value="@(Math.Clamp((double)p.Current / p.Total * 100.0, 0, 100))"
                                           Color="Color.Primary" Style="height: 4px;"/>
                    }
                </div>
            </MudTd>
        }
    </ChildRowContent>
    <PagerContent>
        <MudTablePager/>
    </PagerContent>
</MudTable>

@code {
    [Parameter] public IReadOnlyCollection<PersistedTask> Tasks { get; set; } = [];
    [Parameter] public string Title { get; set; } = "Tasks";
    [Parameter] public string QueryPrefix { get; set; } = "";

    [Parameter] public EventCallback OnClearCompleted { get; set; } = EventCallback.Empty;
    [Parameter] public EventCallback OnClearFailed { get; set; } = EventCallback.Empty;
    [Parameter] public EventCallback<PersistedTask> OnRetryFailed { get; set; } = EventCallback<PersistedTask>.Empty;
    [Parameter] public EventCallback<PersistedTask> OnCancel { get; set; } = EventCallback<PersistedTask>.Empty;
    [Parameter] public EventCallback<PersistedTask> OnRunNow { get; set; } = EventCallback<PersistedTask>.Empty;
    [Parameter] public EventCallback<PersistedTask> OnDelete { get; set; } = EventCallback<PersistedTask>.Empty;

    private MudTable<PersistedTask> Table { get; set; } = null!;

    private List<PersistedTask> cachedTasks = new();

    private bool isFirstLoad = true;

    protected override void OnParametersSet()
    {
        cachedTasks = new List<PersistedTask>(Tasks);
    }

    public async Task ReloadData()
    {
        await Table.ReloadServerData();
    }

    private Task<TableData<PersistedTask>> LoadTasks(TableState state, CancellationToken cancellationToken)
    {
        // On first load, restore state from query parameters
        if (isFirstLoad)
        {
            isFirstLoad = false;
            
            var queryParams = HttpUtility.ParseQueryString(new Uri(NavigationManager.Uri).Query);
            
            string pageKey = string.IsNullOrEmpty(QueryPrefix) ? "page" : $"{QueryPrefix}_page";
            string pageSizeKey = string.IsNullOrEmpty(QueryPrefix) ? "pageSize" : $"{QueryPrefix}_pageSize";
            string sortByKey = string.IsNullOrEmpty(QueryPrefix) ? "sortBy" : $"{QueryPrefix}_sortBy";
            string sortDirKey = string.IsNullOrEmpty(QueryPrefix) ? "sortDir" : $"{QueryPrefix}_sortDir";
            
            if (int.TryParse(queryParams.Get(pageKey), out var page) && page >= 0)
            {
                state.Page = page;
            }
            
            if (int.TryParse(queryParams.Get(pageSizeKey), out var pageSize) && pageSize > 0)
            {
                state.PageSize = pageSize;
            }
            
            var sortBy = queryParams.Get(sortByKey);
            if (!string.IsNullOrEmpty(sortBy))
            {
                state.SortLabel = sortBy;
            }
            
            var sortDirStr = queryParams.Get(sortDirKey);
            if (!string.IsNullOrEmpty(sortDirStr) && Enum.TryParse<SortDirection>(sortDirStr, out var sortDir))
            {
                state.SortDirection = sortDir;
            }
        }

        var query = cachedTasks.AsQueryable();

        query = state.SortLabel switch
        {
            "order_field" => state.SortDirection == SortDirection.Ascending 
                ? query.OrderBy(x => x.Order) 
                : query.OrderByDescending(x => x.Order),
            "name_field" => state.SortDirection == SortDirection.Ascending 
                ? query.OrderBy(x => x.Data.TaskFriendlyName) 
                : query.OrderByDescending(x => x.Data.TaskFriendlyName),
            "queued_field" => state.SortDirection == SortDirection.Ascending 
                ? query.OrderBy(x => x.CreatedAt) 
                : query.OrderByDescending(x => x.CreatedAt),
            "finished_field" => state.SortDirection == SortDirection.Ascending 
                ? query.OrderBy(x => x.ProcessedAt) 
                : query.OrderByDescending(x => x.ProcessedAt),
            "status_field" => state.SortDirection == SortDirection.Ascending 
                ? query.OrderBy(x => x.Status) 
                : query.OrderByDescending(x => x.Status),
            _ => query.OrderBy(x => x.Order)
        };

        UpdateQueryParameters(state);

        var pagedData = query.Skip(state.Page * state.PageSize).Take(state.PageSize).ToList();
        return Task.FromResult(new TableData<PersistedTask> { Items = pagedData, TotalItems = cachedTasks.Count });
    }

    private void UpdateQueryParameters(TableState state)
    {
        var queryParams = HttpUtility.ParseQueryString(new Uri(NavigationManager.Uri).Query);
        
        string pageKey = string.IsNullOrEmpty(QueryPrefix) ? "page" : $"{QueryPrefix}_page";
        string pageSizeKey = string.IsNullOrEmpty(QueryPrefix) ? "pageSize" : $"{QueryPrefix}_pageSize";
        string sortByKey = string.IsNullOrEmpty(QueryPrefix) ? "sortBy" : $"{QueryPrefix}_sortBy";
        string sortDirKey = string.IsNullOrEmpty(QueryPrefix) ? "sortDir" : $"{QueryPrefix}_sortDir";

        bool needsUpdate = false;
        
        if (queryParams.Get(pageKey) != state.Page.ToString())
        {
            needsUpdate = true;
        }
        if (queryParams.Get(pageSizeKey) != state.PageSize.ToString())
        {
            needsUpdate = true;
        }
        if (queryParams.Get(sortByKey) != state.SortLabel)
        {
            needsUpdate = true;
        }
        if (queryParams.Get(sortDirKey) != state.SortDirection.ToString())
        {
            needsUpdate = true;
        }

        if (needsUpdate)
        {
            var newUrl = NavigationManager.GetUriWithQueryParameters(new Dictionary<string, object?>
            {
                [pageKey] = state.Page,
                [pageSizeKey] = state.PageSize,
                [sortByKey] = state.SortLabel,
                [sortDirKey] = state.SortDirection.ToString()
            });
            NavigationManager.NavigateTo(newUrl, forceLoad: false, replace: true);
        }
    }

}
