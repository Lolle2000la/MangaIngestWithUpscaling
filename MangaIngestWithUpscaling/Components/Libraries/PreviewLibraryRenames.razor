@using MangaIngestWithUpscaling.Data.LibraryManagement
@using MangaIngestWithUpscaling.Services.ChapterRecognition
@using MangaIngestWithUpscaling.Services.LibraryFiltering
@using MangaIngestWithUpscaling.Services.MetadataHandling
@using Microsoft.AspNetCore.Components
@inject ILibraryRenamingService RenamingService
@inject IChapterInIngestRecognitionService ChapterRecognition

<MudStack Spacing="2">
    <MudText Typo="Typo.h5">Preview Rename Effects</MudText>
    <MudExpansionPanels>
        <MudExpansionPanel Text="Existing Series Preview">
            <MudTable T="SeriesPreview" Items="@SeriesPreviews" Dense>
                <HeaderContent>
                    <MudTh>Original Series</MudTh>
                    <MudTh>Renamed Series</MudTh>
                </HeaderContent>
                <RowTemplate Context="sp">
                    <MudTd DataLabel="Original Series">@sp.Orig</MudTd>
                    <MudTd DataLabel="Renamed Series">@sp.NewNameHtml</MudTd>
                </RowTemplate>
            </MudTable>
        </MudExpansionPanel>
        <MudExpansionPanel Text="Ingest Folder Preview">
            <MudTable T="IngestPreview" Items="@IngestPreviews" Dense>
                <HeaderContent>
                    <MudTh>Original File</MudTh>
                    <MudTh>After Filters</MudTh>
                    <MudTh>After Rename</MudTh>
                </HeaderContent>
                <RowTemplate Context="ip">
                    <MudTd DataLabel="Original File">@ip.OrigFile</MudTd>
                    <MudTd DataLabel="After Filters">@ip.AfterFilter</MudTd>
                    <MudTd DataLabel="After Rename">@ip.AfterRenameHtml</MudTd>
                </RowTemplate>
            </MudTable>
        </MudExpansionPanel>
    </MudExpansionPanels>
</MudStack>

@code {
    [Parameter, EditorRequired] public required Library Library { get; set; }

    private List<SeriesPreview> SeriesPreviews = new();
    private List<IngestPreview> IngestPreviews = new();

    private class SeriesPreview
    {
        public string Orig { get; set; } = string.Empty;
        public MarkupString NewNameHtml { get; set; }
    }

    private class IngestPreview
    {
        public string OrigFile { get; set; } = string.Empty;
        public string AfterFilter { get; set; } = string.Empty;
        public MarkupString AfterRenameHtml { get; set; }
    }

    protected override void OnParametersSet()
    {
        GeneratePreviews();
    }

    private void GeneratePreviews()
    {
        SeriesPreviews.Clear();
        if (Library.MangaSeries == null || Library.RenameRules == null) return;
        foreach (var m in Library.MangaSeries)
        {
            var dummy = new FoundChapter(string.Empty, string.Empty, ChapterStorageType.Cbz,
                new ExtractedMetadata(m.PrimaryTitle, null, null));
            var renamed = RenamingService.ApplyRenameRules(dummy, Library.RenameRules);
            if (renamed.Metadata.Series != m.PrimaryTitle)
            {
                var orig = m.PrimaryTitle;
                var result = renamed.Metadata.Series;
                var diff = ComputeDiffHtml(orig, result);
                SeriesPreviews.Add(new SeriesPreview { Orig = orig, NewNameHtml = diff });
            }
        }

        IngestPreviews.Clear();
        if (Library.IngestPath == null || Library.FilterRules == null || Library.RenameRules == null) return;
        var found = ChapterRecognition.FindAllChaptersAt(Library.IngestPath, Library.FilterRules);
        foreach (var f in found)
        {
            var renamed = RenamingService.ApplyRenameRules(f, Library.RenameRules);
            if (renamed.FileName != f.FileName)
            {
                var diff = ComputeDiffHtml(f.FileName, renamed.FileName);
                IngestPreviews.Add(new IngestPreview {
                    OrigFile = f.FileName,
                    AfterFilter = f.FileName,
                    AfterRenameHtml = diff
                });
            }
        }
    }

    private MarkupString ComputeDiffHtml(string orig, string result)
    {
        int min = Math.Min(orig.Length, result.Length);
        int start = 0;
        while (start < min && orig[start] == result[start]) start++;
        int end = 0;
        while (end < min - start && orig[orig.Length - 1 - end] == result[result.Length - 1 - end]) end++;
        var prefix = result.Substring(0, start);
        var suffix = end > 0 ? result.Substring(result.Length - end, end) : string.Empty;
        var changed = result.Substring(start, result.Length - start - end);
        var html = $"{prefix}<mark>{changed}</mark>{suffix}";
        return (MarkupString)html;
    }
}
